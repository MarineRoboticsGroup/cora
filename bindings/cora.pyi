from __future__ import annotations
from typing import Any, List, Tuple
from enum import Enum
import numpy as np
from numpy.typing import NDArray


class TNTStatus(Enum):
    Gradient: Any
    PreconditionedGradient: Any
    RelativeDecrease: Any
    Stepsize: Any
    TrustRegion: Any
    IterationLimit: Any
    ElapsedTime: Any
    UserFunction: Any


class Preconditioner(Enum):
    Jacobi: Any
    BlockCholesky: Any
    RegularizedCholesky: Any


class Formulation(Enum):
    Implicit: Any
    Explicit: Any


class Symbol:
    def __init__(self, chr: str, index: int) -> None: ...
    def chr(self) -> str: ...
    def index(self) -> int: ...


class Problem:
    def __init__(self, dim: int, relaxation_rank: int) -> None: ...
    def setRank(self, r: int) -> None: ...
    def setPreconditioner(self, p: Any) -> None: ...
    def setFormulation(self, f: Any) -> None: ...
    def updateProblemData(self) -> None: ...
    def dim(self) -> int: ...
    def addPoseVariable(self, s: Symbol) -> None: ...
    def addLandmarkVariable(self, s: Symbol) -> None: ...
    def addPosePrior(self, *args: Any, **kwargs: Any) -> None: ...
    def addLandmarkPrior(self, *args: Any, **kwargs: Any) -> None: ...
    def addRelativePoseMeasurement(self, *args: Any, **kwargs: Any) -> None: ...
    def addRelativePoseLandmarkMeasurement(self, *args: Any, **kwargs: Any) -> None: ...
    def addRangeMeasurement(self, *args: Any, **kwargs: Any) -> None: ...
    def alignEstimateToOrigin(self) -> None: ...
    # Additional helpers available on the C++ class
    def getDataMatrixSize(self) -> int: ...
    def getExpectedVariableSize(self) -> int: ...
    def getRelaxationRank(self) -> int: ...
    def numPoses(self) -> int: ...
    def numLandmarks(self) -> int: ...
    def numRangeMeasurements(self) -> int: ...
    def numPosesDim(self) -> int: ...
    def projectToManifold(self, A: NDArray[np.float64]) -> NDArray[np.float64]: ...


class CoraTntResult:
    x: NDArray[np.float64]
    f: float
    elapsed_time: float
    objective_values: List[float]
    time: List[float]
    iterates: List[NDArray[np.float64]]
    gradfx_norm: float
    gradient_norms: List[float]
    update_step_norms: List[float]
    preconditioned_grad_f_x_norm: float
    status: TNTStatus
    preconditioned_gradient_norms: List[float]
    inner_iterations: List[int]
    update_step_M_norms: List[float]
    gain_ratios: List[float]
    trust_region_radius: float


class PosePrior:
    def __init__(self, id: Symbol, R: NDArray[np.float64], t: NDArray[np.float64], cov: NDArray[np.float64]) -> None: ...
    def getRotPrecision(self) -> float: ...
    def getTransPrecision(self) -> float: ...


class LandmarkPrior:
    def __init__(self, id: Symbol, p: NDArray[np.float64], cov: NDArray[np.float64]) -> None: ...
    def getPrecision(self) -> float: ...
    def getTransPrecision(self) -> float: ...


class RelativePoseMeasurement:
    def __init__(self, first_id: Symbol, second_id: Symbol, R: NDArray[np.float64], t: NDArray[np.float64], cov: NDArray[np.float64]) -> None: ...
    def toString(self) -> str: ...
    def getRotPrecision(self) -> float: ...
    def getTransPrecision(self) -> float: ...


class RelativePoseLandmarkMeasurement:
    def __init__(self, first_id: Symbol, second_id: Symbol, t: NDArray[np.float64], cov: NDArray[np.float64]) -> None: ...
    def getTransPrecision(self) -> float: ...


class RangeMeasurement:
    def __init__(self, first_id: Symbol, second_id: Symbol, r: float, cov: float) -> None: ...
    def getPrecision(self) -> float: ...



def parsePyfgTextToProblem(path: str) -> Problem: ...


def solveCORA(problem: Problem, x0: NDArray[np.float64], max_relaxation_rank: int = 20,
              verbose: bool = False, log_iterates: bool = False, show_iterates: bool = False) -> Tuple[CoraTntResult, List[NDArray[np.float64]]]: ...


def saddleEscape(problem: Problem, Y: NDArray[np.float64], theta: float, v: NDArray[np.float64],
                 gradient_tolerance: float, preconditioned_gradient_tolerance: float) -> NDArray[np.float64]: ...


def projectSolution(problem: Problem, Y: NDArray[np.float64], verbose: bool = False) -> NDArray[np.float64]: ...


def extractPose(problem: Problem, Y: NDArray[np.float64], pose_sym: Symbol) -> Tuple[NDArray[np.float64], NDArray[np.float64]]: ...


def extractPoint(problem: Problem, Y: NDArray[np.float64], point_sym: Symbol) -> NDArray[np.float64]: ...


class Values:
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    # Methods exposed by the pybind11 bindings
    def set_pose(self, symbol: Symbol, R: NDArray[np.float64], t: NDArray[np.float64]) -> None: ...
    def has_pose(self, symbol: Symbol) -> bool: ...
    def get_pose_rotation(self, symbol: Symbol) -> NDArray[np.float64] | None: ...
    def get_pose_translation(self, symbol: Symbol) -> NDArray[np.float64] | None: ...
    def set_landmark(self, symbol: Symbol, p: NDArray[np.float64]) -> None: ...
    def has_landmark(self, symbol: Symbol) -> bool: ...
    def get_landmark(self, symbol: Symbol) -> NDArray[np.float64] | None: ...


def getValuesFromVarMatrix(problem: Problem, x0: NDArray[np.float64]) -> Values: ...

def getVarMatrixFromValues(problem: Problem, inits: Values) -> NDArray[np.float64]: ...

def updateValuesFromVarMatrix(problem: Problem, inits: Values, x0: NDArray[np.float64]) -> None: ...

def updateVarMatrixRangesBasedOnTranslationVals(problem: Problem, x0: NDArray[np.float64]) -> NDArray[np.float64]: ...

def updateVarMatrixFromValues(problem: Problem, inits: Values, x0: NDArray[np.float64]) -> NDArray[np.float64]: ...

def getRandomValues(problem: Problem) -> Values: ...

def getRandomVarMatrix(problem: Problem) -> NDArray[np.float64]: ...
